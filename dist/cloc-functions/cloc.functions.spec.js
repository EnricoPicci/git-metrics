"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const cloc_functions_1 = require("./cloc.functions");
const path_1 = __importDefault(require("path"));
const delete_file_1 = require("../tools/test-helpers/delete-file");
const rxjs_1 = require("rxjs");
const observable_fs_1 = require("observable-fs");
// #copilot - most of the boilerplate of these tests was generated by copilot
describe('runCloc', () => {
    it('should return an array of language statistics', (done) => {
        (0, cloc_functions_1.clocSummary$)('./src').subscribe((stats) => {
            (0, chai_1.expect)(stats instanceof Array).to.be.true;
            (0, chai_1.expect)(stats.length).greaterThan(0);
            (0, chai_1.expect)(!!stats[0].language).to.be.true;
            (0, chai_1.expect)(stats[0].nFiles).greaterThan(0);
            (0, chai_1.expect)(stats[0].blank).greaterThan(0);
            (0, chai_1.expect)(stats[0].comment).greaterThan(0);
            (0, chai_1.expect)(stats[0].code).greaterThan(0);
            done();
        });
    }).timeout(10000);
    it('should return statistics for TypeScript files', (done) => {
        (0, cloc_functions_1.clocSummary$)('./src').subscribe((stats) => {
            const typescriptStats = stats.find((stat) => stat.language === 'TypeScript');
            (0, chai_1.expect)(!!typescriptStats).to.be.true;
            (0, chai_1.expect)(typescriptStats.nFiles).greaterThan(0);
            (0, chai_1.expect)(typescriptStats.blank).greaterThan(0);
            (0, chai_1.expect)(typescriptStats.comment).greaterThan(0);
            (0, chai_1.expect)(typescriptStats.code).greaterThan(0);
            done();
        });
    }).timeout(10000);
    it('should return statistics reading from a git repo commit - the commit is from the repo of this project', (done) => {
        (0, cloc_functions_1.clocSummary$)('2c6f2ae87b539590f5a0f93682f5440ca845bc9c').subscribe((stats) => {
            const typescriptStats = stats.find((stat) => stat.language === 'TypeScript');
            (0, chai_1.expect)(!!typescriptStats).to.be.true;
            (0, chai_1.expect)(typescriptStats.nFiles).greaterThan(0);
            (0, chai_1.expect)(typescriptStats.blank).greaterThan(0);
            (0, chai_1.expect)(typescriptStats.comment).greaterThan(0);
            (0, chai_1.expect)(typescriptStats.code).greaterThan(0);
            done();
        });
    }).timeout(10000);
});
describe('buildOutfileName', () => {
    const thisFolderName = 'git-metrics';
    it('should return the provided output file name if it is provided', () => {
        const outFile = 'output.txt';
        const result = (0, cloc_functions_1.buildOutfileName)(outFile);
        (0, chai_1.expect)(result).to.equal(outFile);
    });
    it('should generate an output file name based on the provided parameters', () => {
        const prefix = 'prefix_';
        const repoFolder = '/path/to/repo';
        const postfix = '_postfix';
        const expected = `${prefix}repo${postfix}`;
        const result = (0, cloc_functions_1.buildOutfileName)('', repoFolder, prefix, postfix);
        (0, chai_1.expect)(result).to.equal(expected);
    });
    it('should use the current working directory name as the base folder name since repo folder is not passed as param', () => {
        const prefix = 'prefix_';
        const postfix = '_postfix';
        const expected = `${prefix}${thisFolderName}${postfix}`;
        const result = (0, cloc_functions_1.buildOutfileName)('', '', prefix, postfix);
        (0, chai_1.expect)(result).to.equal(expected);
    });
    it('should use an empty string as the prefix if prefix is not provided', () => {
        const repoFolder = '/path/to/repo';
        const postfix = '_postfix';
        const expected = `repo${postfix}`;
        const result = (0, cloc_functions_1.buildOutfileName)('', repoFolder, undefined, postfix);
        (0, chai_1.expect)(result).to.equal(expected);
    });
    it('should use an empty string as the postfix if postfix is not provided', () => {
        const prefix = 'prefix_';
        const repoFolder = '/path/to/repo';
        const expected = `${prefix}repo`;
        const result = (0, cloc_functions_1.buildOutfileName)('', repoFolder, prefix, undefined);
        (0, chai_1.expect)(result).to.equal(expected);
    });
    it('should use the current working directory name as the base folder name if repoFolder is "."', () => {
        const prefix = 'prefix_';
        const postfix = '_postfix';
        const expected = `${prefix}${thisFolderName}${postfix}`;
        const result = (0, cloc_functions_1.buildOutfileName)('', '.', prefix, postfix);
        (0, chai_1.expect)(result).to.equal(expected);
    });
    it('should use the current working directory name as the base folder name if repoFolder is "."', () => {
        const prefix = 'prefix_';
        const postfix = '_postfix';
        const expected = `${prefix}${thisFolderName}${postfix}`;
        const result = (0, cloc_functions_1.buildOutfileName)('', './', prefix, postfix);
        (0, chai_1.expect)(result).to.equal(expected);
    });
    it('should use the current working directory name as the base folder name if repoFolder is an empty string', () => {
        const prefix = 'prefix_';
        const postfix = '_postfix';
        const expected = `${prefix}${thisFolderName}${postfix}`;
        const result = (0, cloc_functions_1.buildOutfileName)('', '', prefix, postfix);
        (0, chai_1.expect)(result).to.equal(expected);
    });
});
describe(`writeClocByFile$`, () => {
    it(`read the number of lines for each file from the folder named as the repo and saves them in a file - works in a new process`, (done) => {
        const repo = 'git-repo-with-code';
        const outDir = path_1.default.join(process.cwd(), './temp');
        const outClocFilePrefix = 'new-process';
        const config = {
            folderPath: `./test-data/${repo}`,
            outDir,
            outClocFilePrefix,
        };
        const expectedOutFilePath = outDir + '/' + outClocFilePrefix + repo + '-cloc-byfile.csv';
        let counter = 0;
        (0, delete_file_1.deleteFile)(expectedOutFilePath)
            .pipe((0, rxjs_1.concatMap)(() => (0, cloc_functions_1.writeClocByFile$)(config, 'test')), (0, rxjs_1.tap)({
            next: (returnedOutFilePath) => {
                (0, chai_1.expect)(returnedOutFilePath).equal(expectedOutFilePath);
                counter++;
            },
        }), (0, rxjs_1.concatMap)((returnedOutFilePath) => (0, observable_fs_1.readLinesObs)(returnedOutFilePath)), (0, rxjs_1.tap)({
            next: (lines) => {
                (0, chai_1.expect)(lines).not.undefined;
                // there are 5 lines: 3 for the 3 files and 1 for the csv header, which is the first, and one for the sum which is the last
                (0, chai_1.expect)(lines.length).equal(5);
                const _fileName = 'hallo.java';
                const [language, filename, blank, comment, code] = lines
                    .find((l) => l.includes(_fileName))
                    .split(',');
                (0, chai_1.expect)(language).equal('Java');
                (0, chai_1.expect)(filename).equal(`${_fileName}`);
                (0, chai_1.expect)(parseInt(blank)).equal(3);
                (0, chai_1.expect)(parseInt(comment)).equal(1);
                (0, chai_1.expect)(parseInt(code)).equal(5);
            },
        }))
            .subscribe({
            error: (err) => done(err),
            complete: () => {
                (0, chai_1.expect)(counter).equal(1);
                done();
            },
        });
    }).timeout(200000);
});
describe(`writeClocSummary`, () => {
    it(`read the summary view provided by cloc from the folder named as the repo and saves it in a file`, (done) => {
        const repo = 'git-repo-with-code';
        const outDir = path_1.default.join(process.cwd(), './temp');
        const config = {
            folderPath: `./test-data/${repo}`,
            outDir,
        };
        const expectedOutFilePath = path_1.default.join(outDir, `${repo}-cloc-summary.csv`);
        const returnedOutFilePath = (0, cloc_functions_1.writeClocSummary)(config, 'test');
        (0, chai_1.expect)(returnedOutFilePath).equal(expectedOutFilePath);
        (0, observable_fs_1.readLinesObs)(returnedOutFilePath).subscribe({
            next: (lines) => {
                (0, chai_1.expect)(lines).not.undefined;
                // there are 4 lines: 2 for the 2 languages (java nd python) and 1 for the csv header, which is the first,
                // and one for the sum which is the last
                (0, chai_1.expect)(lines.length).equal(4);
                const _language = 'Java';
                const [files, language, blank, comment, code] = lines.find((l) => l.includes(_language)).split(',');
                (0, chai_1.expect)(language).equal('Java');
                (0, chai_1.expect)(parseInt(files)).equal(2);
                (0, chai_1.expect)(parseInt(blank)).equal(3);
                (0, chai_1.expect)(parseInt(comment)).equal(3);
                (0, chai_1.expect)(parseInt(code)).equal(10);
            },
            error: (err) => done(err),
            complete: () => done(),
        });
    }).timeout(200000);
});
//# sourceMappingURL=cloc.functions.spec.js.map